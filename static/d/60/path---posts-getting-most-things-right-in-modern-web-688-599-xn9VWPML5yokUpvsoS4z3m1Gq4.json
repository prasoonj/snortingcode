{"data":{"site":{"siteMetadata":{"title":"Snorting Code, Et al.","subtitle":"I don't take myself too seriously!","copyright":"© All rights reserved.","author":{"name":"Prasoon","twitter":"prasoonj"},"disqusShortname":"snortingcode","url":"https://prasoonj.github.io/snortingcode"}},"markdownRemark":{"id":"9af23b85-c80f-5bb3-88bf-8e9768a99c56","html":"<p>We wold be creating an interest mapper webapp. Users of this app\nwould provide a bunch of things they are interested in and the tool will\n(with some ML magic) find the people they should get in touch with. It\nwould also auto generate interactive dashboards for popular interests.[You\nwould require familiarity with a few things before you start here. In\nmost cases it would mean that you have the tool installed and know how\nto put it to a very basic use:* nodeJs * npm (nodeJs’s package manager)(Be careful to install npm the right way! You should be able to install packages locally as well as globally (-g) without needing sudo privileges)]Let’s\nget started by creating a directory for where our cool web-app will\nreside. We will install the packages we need as we work our way through\nthis guide. $ mkdir find-my-buddy &#x26;&#x26; cd find-my-buddyThe dependencies for the project can be defined in a “package.json” file within this directory and installed by:$ npm install # We would not be doing this though. We would install each package# as we find need for it. Just know that this is the standard way of# going about things. But, most of these packages are best installed# globally anyway.BowerPackage management on the front-end side of things is best done with Twitter’s Bower. Any front-end relevant artifact can be easily included in your project. If you have experience in back-end technologies you can compare it with Maven (for Java) or virtuanenv (for Python). It keeps packages local to the project - you can have the same dependency at different versions for different projects. This should not be a big surprise because the dependencies in a front-end project are tucked away in a folder specific to the project but, it is a cool parallel to the way things are done with packages that need to be installed with other technologies and one can easily create conflicts between system-wide installations and those required by a project having different versions.Here’s how things work:# Install bower using npm, our friendly package manager, globally$ npm install -g bowerWhen you install a package with bower it goes and sits neatly into “bower-components” directory, organized by the package names.Let’s try that out with the trusty and essential jquery library:# Make sure we are inside the project directory we created earlier</p>\n<p>$ bower install jquerybower cached        git://github.com/jquery/jquery.git#2.1.4bower validate      2.1.4 against git://github.com/jquery/jquery.git#<em>bower install       jquery#2.1.4jquery#2.1.4 bower<em>components/jquery#Let’s see what it did$ tree -L 3 ..`— bower</em>components    <code class=\"language-text\">-- jquery        |-- bower.json        |-- dist        |-- MIT-LICENSE.txt</code>— src4 directories, 2 filesCouple of things that it did was to create a directory for all the packages that would be installed for the project - “bower-components” - and put the “jquery” component in there.Inside the “jquery” directory the contents are of interest that’ll help us understand the way things are organized using the best practices which we would use to organize our own project as welljquery # all files will reside under this component directory        |— bower.json # bower’s package file - more later        |— dist # directory containing all compiles resources        |— MIT-LICENSE.txt # duh!        `— src # sources used to build the ‘dist’ directory’s contents4 directories, 2 files When we build our project, our files will also go into the ‘dist’ directory too (at a different location of course).This is all sweet but, we don’t want to issue the install command repeatedly for each package we want to use. Also, we started off by saying this bower thing is a package manager so, let’s see how that works.# Again from inside the project directory$ bower init# This would initialize this project as a bower managed project# and create a bower.json file for you (after asking some very # useful questions. The bower.json would look like:{  name: ”find-my-buddy”,  version: ”0.0.0”,  description: ”Find your activity partner”,  authors: [    ”prasoonj”  ],  license: ”MIT”,  ignore: [    ”**/.</em>”,    ”node<em>modules”,    ”bower</em>components”,    ”test”,    ”tests”  ],  dependencies: {    jquery: ”~2.1.4”  }}You can even create this bower.json ‘by hand’ and work your way up. The “dependencies” section of the json is where we would define the packages that we require - along with their version numbers where necessary. Bower can work independently as a package manager for your project but, it’s real power is when used with other tools like Grunt, Yeoman, etc.Take a look at the API docs for bower to learn more. Most of the stuff there is for package publishers and you would probably not use it if you are just using bower to build a webapp the correct way.Let’s get a move on to other cool stuff.Grunt# Just like before, let’s start with installing this package with npm$ npm install -g grunt-cliGrunt-cli is not the grunt task runner!Okay, let’s step back a bit and see what grunt is and what it does. Grunt is a lot of things based on how you use it. In a nutshell, it is an automation framework for your front-end project that let’s you automate the common tasks that you would engage yourself with on a regular basis. The grunt ecosystem comprises of a bunch of awesome plugins that help you in this automation - compiling less scripts, starting a test server, running tests - all of this and more. If you don’t find what you are looking for, you can make your own plugins!After installing grunt-cli at a global level, you would have access to grunt command from any project. Executing grunt from a directory would look for a locally installed instance and take things forward. So, first step is to have a locally installed grunt task runner.# Let’s create a package.json file and provide ‘grunt’ as a # “devDependencies” so that node can install it. # We can create a package.json file “by hand” or use the uber-useful# utility - npm init$ npm init# A series of helper questions follow that guide you through the# process of providing values (with clever defaults) to the fields# of the final package.json file. The result in my case was:{  “name”: “find-my-buddy”,  “version”: “0.0.1”,  “description”: “Find your activity partner”,  “main”: “index.js”,  “scripts”: {    “test”: “echo ”Error: no test specified” &#x26;&#x26; exit 1”  },  “author”: “smotchkiss”,  “license”: “MIT”}# Let’s install grunt locally for this project and add it as a # dependency to the package.json$ npm install grunt —save-dev# This would do two things - install ‘grunt’, creating node-modules# directory and add the grunt entry in the ‘devDependencies’ of # package.json. This is how the project looks like now:.|— bower<em>components|   `— jquery|— bower.json|— node</em>modules|   <code class=\"language-text\">-- grunt</code>— package.json# And here’s the updated package.json{  “name”: “find-my-buddy”,  “version”: “0.0.1”,  “description”: “Find your activity partner”,  “main”: “index.js”,  “scripts”: {    “test”: “echo ”Error: no test specified” &#x26;&#x26; exit 1”  },  “author”: “smotchkiss”,  “license”: “MIT”,  “devDependencies”: {    “grunt”: “^0.4.5”  }}From now on, we can just add the packages required by grunt to the package.json file and ask npm to install them for us if they are not already there using - npm install.Next, we need a gruntfile. We would not go into the details of the contents of the gruntfile beyond few essential things that we require. You can read more about it here: gruntfile introduction.Grunt would provide tasks that can be run on the project based on the plugins registered in the gruntfile. Let’s create a basic gruntfile and register a few plugins.The plugin that you register needs to be installed via npm first!# This is what our sample Gruntfile.js looks like. Ignore the details# for now. module.exports = function(grunt) {    //Importing project configuration from package.json    grunt.initConfig({        pkg: grunt.file.readJSON(”package.json”),        uglify: {            options: {                banner: ”/* &#x3C;%= pkg.name %> &#x3C;%= grunt.template.today(“yyyy-mm-dd”) %> */ \\n”            },            build: {                src: ”src/&#x3C;%= pkg.name %>.js”,                dest: ”build/&#x3C;%= pkg.name %>.min.js”            }        }    });    //Load plugins    grunt.loadNpmTasks(”grunt-contrib-uglify”);    //Define default tasks    grunt.registerTask(”default”, [”uglify”]);};# The important parts of this file for now are the way we import # the configuration from package.json file, the way we register packages# and the way we define ‘defaults’.# Based on the packages registered in the Gruntfile, we would get a list# of ‘tasks’ that are available. The tasks defined as ‘default’ would be# performed automatically when ‘grunt’ command is used on the project.# To see a complete list of available tasks:$ grunt —helpThe utility of grunt would be visible when we include features in our project that require a regular ‘task’ to be performed - things like tests, compiling less files, etc.Let’s add a few bower components that we would be using to make the first cut of our app - angularjs, bootstrap.[My intention was to create one massive post that does a ‘start-to-finish’ of a web-app. Sadly, if I go that route, I would either be missing out the details that I want to provide for each component or would end up making this post one large monolith, adding to the already overflowing TL;DR guides. To ease that burden, I would cover angularjs and bootstrap in a future post (coming very soon - promise!)]# In the dependencies section of the bower.json file add the entries # for angularjs and bootstrapdependencies: {    jquery: ”~2.1.4”,    angular: ‘~1.4.3′,    bootstrap: ‘3.x.x’  }# Installing these is simple:$ bower installThis would create the required directories inside ‘bower-components’ and would ensure that we have all we need before we start out to see some angular magic on our bootstrap templates.You would notice that the angular directory has just the js files while the bootstrap directory has its own bower.json file, package.json file and a grunt task runner. This different is due to the fact that we would not be changing the code angularjs’s code, all our custom code would go into another package defining the logic of our application. However, even though we would not change the bootstrap css either, we would change one special less file there to include a single line to it so that our custom less code is compiled without interfering with the existing bootstrap classes (preserving the overrides that we would provide) and at the same time upgrading bootstrap would not wipe out the customizations that we have done. This would be a major hair-puller otherwise when you upgrade your bootstrap to a new version.[Wait for the future versions of this guide that would cover - angular, bootstrap, less, karma, jasmine and some basics of JavaScript that are required to understand how angular works]</p>","fields":{"tagSlugs":["/tags/bower/","/tags/grunt/","/tags/npm/","/tags/nodejs/","/tags/frontend/","/tags/angularjs/","/tags/bootstrap/"]},"frontmatter":{"title":"Getting (Most) Things Right In Modern Web Front-end Development.","tags":["bower","grunt","npm","nodejs","frontend","angularjs","bootstrap"],"date":"2015-07-15T00:36:43+05:30","description":"This ancient opinion/guide would do you no good!"}}},"pageContext":{"slug":"/posts/getting-most-things-right-in-modern-web"}}