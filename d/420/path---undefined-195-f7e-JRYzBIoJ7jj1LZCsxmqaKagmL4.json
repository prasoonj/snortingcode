{"data":{"site":{"siteMetadata":{"title":"Snorting Code, Et al.","subtitle":"I don't take myself too seriously!","copyright":"© All rights reserved.","author":{"name":"Prasoon","twitter":"prasoonj"},"disqusShortname":"","url":"https://prasoonj.github.io/snortingcode"}},"markdownRemark":{"id":"0fbe448f-21cb-541d-8285-3e3e66d89b58","html":"<p>[This is part of a series of posts on Scala and Functional Programming:\nPart 1: Scala Tricks - tupled/untupled</p>\n<p>Part 2: Higher Order Functions</p>\n<p>Part 3: Cooking yummy Functional code - (partial, curry, compose)!</p>\n<p>For a basic introduction to Scala, syntax, etc. you can check out Scala Fast Lane\n]</p>\n<p>I don’t intend to turn this post into a click-bait article but, I find these 3 Functional Programming principles to be fundamental to understanding FP it well. Without them, you would write imperative code in your favorite functional programming language!</p>\n<p>You would notice that they weave into each other and produce some rather beautiful imagery about FP.</p>\n<blockquote>\n<p>Partial Functions</p>\n</blockquote>\n<p>Let’s begin with Partial functions. The idea is neat, if you have a function that takes several arguments, you can convert it into a function that that takes fewer arguments. You produce this magic by creating a function that fills-in the rest of the argument values and returning the same function.</p>\n<p>In the example below, we’ll take a function <code class=\"language-text\">f: (A, B) =&gt; C</code> (takes 2 arguments of types A and B and returns a type C) and convert it into a partial function that takes the value for the first argument and returns a function that just needs the second argument to produce the C that you needed!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">scala&gt; def partial[A,B,C](a: A, f: (A,B) =&gt; C): B =&gt; C = (b:B) =&gt; f(a, b)\npartial: [A, B, C](a: A, f: (A, B) =&gt; C)B =&gt; C</code></pre></div>\n<p>[If the parameterised type signature looks scary to you, you should read more about it and come back here. It is there for a reason. It emphasises the need for functions like these!]</p>\n<blockquote>\n<p>Currying</p>\n</blockquote>\n<p>Next, let’s look at currying. A (rather silly) analogy to understand currying is to think of yourself as an indian housewife making a great indian curry for your family in the evening! The number of ingredients that you would need can be intimidating so there are 2 things you do -</p>\n<p>Combine few ingredients together so that they are easier to handle (the typical off-the-shelf sambar poweder!).\nAdd them one after the other till you get the curry your family loves!\nCurrying converts a function that takes N arguments into a function that takes one argument. This new function returns another function. If we go back to our analogy, each ‘step’ in this currying process is a function application that takes you closer to your goal - the yummy result of a function that needs a ton of arguments.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">scala&gt; def curry[A,B,C](f: (A, B) =&gt; C): A =&gt; (B =&gt; C) = (a: A) =&gt; (b: B) =&gt; f(a, b)\ncurry: [A, B, C](f: (A, B) =&gt; C)A =&gt; (B =&gt; C)</code></pre></div>\n<p>There are reasons to confuse currying and partial functions. Here’s some insight that might help:</p>\n<p>Look at the type signatures of the two:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">partial: [A, B, C](a: A, f: (A, B) =&gt; C)B =&gt; C</code></pre></div>\n<p>vs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curry: [A, B, C](f: (A, B) =&gt; C)A =&gt; (B =&gt; C)</code></pre></div>\n<p>In partial, you are “applying” one of the arguments so the returned function is free of A. Its job is done! But, in curry, you get a function that needs just one of the arguments and passes the buck to the function that it then returns!</p>\n<p>Think of a partial application as “forgetful” and currying as, well, like I said, the curry recipe will always be able to tell you how you reached there!</p>\n<blockquote>\n<p> Function Composition</p>\n</blockquote>\n<p>The last piece of the puzzle here is function composition. Well, TBH, I’m rather certain that you are already quite familiar with function composition so, I’ll include it here just for completeness (in some shallow sense :D )</p>\n<p>The only analogy you need here is the idea of pipes from your terminal/shell! You “pipe” the output of one function as input to another function and you have function composition.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">scala&gt; def compose[A, B, C](f: B =&gt; C, g: A =&gt; B): A =&gt; C = (a: A) =&gt; f(g(a))\ncompose: [A, B, C](f: B =&gt; C, g: A =&gt; B)A =&gt; C</code></pre></div>\n<p>This is the same as: <code class=\"language-text\">g compose f or f andThen g</code>, where <code class=\"language-text\">compose</code> and <code class=\"language-text\">andThen</code> are utility functions provided by scala, which might make you notice that we did not use any magic function to explain what partial and curry were all about! Well, the magic of FP is probably hidden in the fact that there is no magic. We could use the elementary idea of higher order functions and build everything from there!</p>","fields":{"tagSlugs":["/tags/functional-programming/","/tags/scala/","/tags/currying/","/tags/partial-function/","/tags/function-composition/"]},"frontmatter":{"title":"Cooking yummy Functional code - (partial, curry, compose)!","tags":["functional programming","Scala","currying","partial function","function composition"],"date":"2018-03-19T05:30:45+05:30","description":null}}},"pageContext":{"slug":"/undefined/"}}