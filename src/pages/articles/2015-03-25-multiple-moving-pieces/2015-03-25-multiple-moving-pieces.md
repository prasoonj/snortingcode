---
layout: post
title: Multiple Moving Pieces
date: '2015-03-25T05:45:55+05:30'
tags:
- project management
- software development
tumblr_url: http://snortingcode.tumblr.com/post/114570583005/multiple-moving-pieces
draft: false
path: /posts/multiple-moving-pieces-software-design
category: ramblings
description:

---
Brace yourselves, this is going to be a rather long post with many scenarios, several aspects and a lot of incremental change to each of them!Any moderately complex system would have multiple moving parts, multiple teams working in various combinations on those parts and each part progressing at it’s own pace. Project management then, is not simple task! (But, would you be weighed in gold for every paycheck if it was simple?!)Let’s consider this simple analogy - consider that you are a literature Nobel laureate writing her next best novel. A fiction piece that talks about how a town survived the attack of alien zombies! (Scary thought already right?) The basic story line is straight forward - the alien zombie attack is predicted by the oracle, a team of superheros is put together who orchestrate the ‘save the earth’ mission. Now, since you know a thing or two about fiction writing, you understand that the readers would already know that the book can be summarized in one line - “An army of alien zombies attack the earth, a group of superheros form a team to defeat them. Everyone lives happily, ever after.” The idea of writing this book is in the juice of the characters in it. As you go along telling the story, moving from event to event, you are evolving your characters. The two lead superheros are falling in love with each other, the two angry ones are coming to terms with working in the same team towards a common goal, the most powerful of them all has time to hone her skills that would be used in a sequel that you have planned but not announced! Above all, though all of them have their egos and problems, they must all finally come together and make each event of the story a success.As the author, your task is to make sure each element of the book moves in a specific direction, each character is brought up to speed to actuate an event as planned by you and each character is strong enough to etch its mark in the memory of the readers.Let’s get back to software development. Your task is just as complex (and artful) as of this author. You have a project to deliver that comprises of many moving parts, each of them have their own development timelines/issues, all of the moving parts must work together at each important juncture (call it releases or what you may).Primary considerationsIdentification of all moving parts - It is the first and most natural thing to do. Identify all the different components. I would suggest a pessimistic approach here. Divide as much as possible, it might be simpler to club a few together later on but, splitting a monolith is always going to be a challenge. Do not go by the teams that you have - for instance, if you have a bunch of web developers in a team there is no need to club a RESTful API and a web based front-end together. What if you decided to go mobile one day (even if this was something that was agreed upon as a ‘never gonna happen’ requirement). If a certain component is going to develop incrementally with requirement flowing in intermittently, see if the requirement gathering mechanism itself could be visualized as a component (this would be clear when we talk about interfaces and component interaction).Defining interfaces and interactions - Once components are on the board, it should be quite clear how they would interact with each other. Always follow the best practices for each component interface. There is a pattern for OO language interfaces that talks about “open close principle” which can be applied to our components here too - make each (published) component open for extension and closed for modification. Let’s take the case of a REST API; a requirement comes up that requires few more parameters for requesting an object from an endpoint - this new requirement should not break old functionality (you can version the API, use clever ways of making your API future proof, use good error/feedback mechanism to inform the consumer exactly what is missing, etc.) The interface contract between any two components has to be sacrosanct! Treat this as a protocol - spend a lot of time in considering all possible scenarios and freeze it before each component is developed! In a situation when this has to be changed, see if the open-close principle can be taken into account. Changing the way two pieces in a system interact should be taken as a serious design flaw. We talked about treating the requirement gathering mechanism as a distinct component, the thumb of rule could be - if the requirements are transient in nature, incremental and a specifications document is exposed to the development team, this document could serve as an interface between the business folk and the developers of this particular module (think of innovative ways in which this document can be included in an automation chain - avoid capturing such requirements in an spreadsheet!)Version control - This is probably the simplest thing to get wrong! The thumb rule here should be simple - each component should live in its own project that is capable of building an artifact independent of all other component. This would allow each component to evolve independent of the others, as long as the interfaces are strong and unchanging (and well documented) we’d all be a happy bunch. This is best understood by how things can go wrong - Imagine a project that is split into 2 parts: part one consists of pig scripts that carry out the ETCL for some data files, second part takes the transformed data and carries out MDM on it using different sources. If both these components are sitting in a single project, there would be no way to have a stable single version of the first component that can play with the other component. Each component is now tightly coupled with the other at the version control level even though they are separate units functionally and structurally! Bad design! The two components in all probability are developed by separate teams but this simple mistake requires that they are joined at the hip for all practical purposes!Traceability - The interfaces should either serve as traceability or should have a mapping to the traceability document/mechanism. In case any variation is detected from the traceability document, these would effect a change on the interfaces (less desired) in the worst case. A tight coupling/control over traceability and interfaces then becomes a necessity. There can be a simple rule - the interface should be modified structurally/functionally only when the change in requirements effect a change in the traceability document. In such a case, there larger project wide requirement would need to be broken down into component level traceability document elements which would eventually give a better control over the process and help in catch requirement related bugs very early in the development life cycle (even if you follow a non-agile or a semi-agile methodology).There is a standard pattern to go about this that you must look into - hexagonal architecture. Here, there is essentially a ‘core’ of the project on top of which the different teams place ‘enhancements’ and ‘interactions’. If a specific ‘core’ is not entirely visible or even applicable in your case, you can consider this core to be an agreed upon set of protocols or a common point where most components meet and which remains sacrosanct for all practical purposes. You can think of that as a central port/adapter. It could even be a traceability document!(I would love to evolve, improve and correct this post with your inputs. Do comment or mail me your thoughts.)
